# 2026-02-20 作業ログ

## 概要

Phase 6（Burnside の補題による非同型数え上げ）のメモリ最適化を行った。
ZDD を分割して SymmetryFilter を適用する方式により、s12L のピークメモリを 6.5GB → 2.8GB に削減（57% 削減）。時間も 62.5s → 53.2s に高速化（15% 高速化）。

---

## 背景

### プロジェクト構成

CountingNonoverlappingUnfoldings: 多面体の非重複展開図を数え上げるプロジェクト。

パイプライン:
- Phase 4: 全域木 ZDD 構築（SpanningTree DdSpec）
- Phase 5: 非重複フィルタリング（UnfoldingFilter で MOPE ごとに zddSubset + zddReduce）
- Phase 6: Burnside の補題で非同型数え上げ（SymmetryFilter で各自己同型 g に対して |T_g| を計算）

### Phase 6 のボトルネック

各非恒等自己同型 g に対して:
1. Phase 5 結果 ZDD を deep copy（`privateEntity()` で refCount=1 に）
2. `zddSubset(SymmetryFilter)` → unreduced 中間 ZDD が巨大（s12L: 574M ノード = 8.7GB）
3. `zddReduce()` → reduce 中に旧テーブル + 新テーブルが同時存在
4. `zddCardinality()` → カウント

ピークメモリは step 2 の unreduced 中間 ZDD が支配的。

---

## 今回の変更内容

### 変更ファイル

- `cpp/spanning_tree_zdd/src/main.cpp` のみ

### 変更の要点

**ZDD 分割 + shallow copy 方式** を導入:

1. **EdgeRestrictor DdSpec** を新規追加（main.cpp 内に定義）
   - 上位 `depth` 辺（辺0, 辺1, ... 辺depth-1）の値を特定のビットパターンに制約するフィルタ
   - `tdzdd::DdSpec<EdgeRestrictor, int, 2>` を継承

2. **`#include <tdzdd/DdSpecOp.hpp>`** を追加
   - `tdzdd::zddIntersection()` を使用するため

3. **`run_burnside_with_bitmask` の非恒等自己同型処理を変更**

   旧:
   ```cpp
   tdzdd::DdStructure<2> dd_copy(dd);
   dd_copy.getDiagram().privateEntity();  // deep copy
   SymmetryFilter<BitMask> filter(num_edges, perm);
   dd_copy.zddSubset(filter);
   dd_copy.zddReduce();
   count = dd_copy.zddCardinality();
   ```

   新:
   ```cpp
   const int split_depth = 3;  // K=8 パーティション
   const int num_partitions = 1 << split_depth;
   string partition_sum = "0";

   for (int p = 0; p < num_partitions; ++p) {
       tdzdd::DdStructure<2> dd_part(dd);  // shallow copy (deep copy 不要)

       EdgeRestrictor restrictor(num_edges, split_depth, p);
       SymmetryFilter<BitMask> sym_filter(num_edges, perm);
       auto combined = tdzdd::zddIntersection(restrictor, sym_filter);
       dd_part.zddSubset(combined);
       dd_part.zddReduce();

       partition_sum = bigint_add(partition_sum, dd_part.zddCardinality());
   }
   count = partition_sum;
   ```

### なぜ動くか

- 「辺0=0 の全域木」と「辺0=1 の全域木」は排他的 (disjoint)
- 上位 d 辺で 2^d パーティションに分割 → 各パーティションの中間 ZDD ≈ 元の 1/2^d
- パーティションが排他的なので zddUnion 不要、**カーディナリティを足すだけ**
- `zddIntersection(EdgeRestrictor, SymmetryFilter)` で合成フィルタを作成し、1 回の zddSubset で分割制約 + 対称性フィルタを同時適用
- EdgeRestrictor が上位レベルで即座に枝刈り → SymmetryFilter の処理対象が 1/K に

### なぜ shallow copy で動くか

- `zddSubset_()` 内の `diagram.derefLevel(i)` は refCount==1 の場合のみレベルを解放
- shallow copy (refCount=2) では derefLevel は no-op → 入力 ZDD は解放されないが subset 結果は正しい
- deep copy コスト（`privateEntity()` の全テーブルコピー）が完全に不要に

---

## 計測結果

### n20 (Johnson 立体, 45辺, 自己同型群位数10)

| | Phase 6 時間 | ピークメモリ |
|---|---|---|
| 元の実装 | 217ms | 162MB |
| 分割方式 (K=8) | 302ms | **79MB** |
| 変化 | +39% | **-51%** |

### s12L (Archimedean 立体, 60辺, 自己同型群位数24)

| | Phase 6 時間 | ピークメモリ |
|---|---|---|
| 元の実装 | 62.5s | **6.5GB** |
| 分割方式 (K=8) | 53.2s | **2.8GB** |
| 変化 | **-15%** | **-57%** |

### 正解値

- n20: nonisomorphic_count = `2715815541` ✓
- s12L: nonisomorphic_count = `3581988230895` ✓

---

## 試して失敗したアプローチ（この会話内）

### 1. InvariantCounter.hpp（自作 subsetter）

前回の会話で作成した ZddSubsetter を模倣した自作実装。
s12L: 53s / 5.5GB と高速化・メモリ削減できたが、TdZdd ライブラリの内部構造を再現しているためバグリスクが高い。ユーザ判断で revert。

### 2. zddReduce 追加（InvariantCounter + DdReducer）

InvariantCounter の出力に DdReducer を適用。n20 では効果あり（94MB）だが s12L では逆効果（8.2GB）。DdReducer 内部で privateEntity() がテーブルをコピーするため、巨大な unreduced ZDD に対しては逆にメモリが増加。

### 3. zddIntersection(SpanningTree, SymmetryFilter) で直接構築

g-不変全域木 ZDD を SpanningTree と SymmetryFilter の intersection で直接構築。
理論上は良いが、combined state（frontier 状態 + BitMask）の爆発 + 72 MOPEs を各自己同型ごとに再適用するため、s12L で非常に遅い。n20 でも Phase 6 が 678ms に悪化。

---

## 現在の状態

- `main.cpp` は変更済み・**未コミット**
- `InvariantCounter.hpp` は削除済み
- ビルド済み・テスト通過
- `git status` で差分あり

---

## 次に必要なこと

### 1. コミット

現在の変更をコミットする。コミットメッセージ案:
```
refactor: partition ZDD for memory-efficient Phase 6 symmetry filtering

Split ZDD into 2^d disjoint partitions using EdgeRestrictor and apply
SymmetryFilter to each partition separately via zddIntersection. Sum
cardinalities instead of building union. Use shallow copy to avoid
deep copy overhead. Reduces s12L peak memory from 6.5GB to 2.8GB (-57%)
and Phase 6 time from 62.5s to 53.2s (-15%).
```

### 2. split_depth の調整検討

現在 `split_depth = 3`（K=8）でハードコード。
- より大きなインスタンスでは depth を増やす必要があるかもしれない
- コマンドライン引数化やインスタンスサイズに基づく自動調整を検討
- ただし、現状で十分に効果があるので急ぎではない

### 3. より大きなインスタンスでのテスト

s12L 以外の大きなインスタンス（例: Archimedean 立体 s08, s10 など）で
メモリ使用量と正確性を確認する。

### 4. InvariantCounter.hpp の削除確認

`InvariantCounter.hpp` は既に `rm` で削除済みだが、git 上では tracked file の削除として差分に出る。
コミット時に含める。

### 5. ディスク I/O 方式（将来の検討）

Phase 5 ZDD 自体をディスクに書き出し、各パーティション処理時に読み込む方式。
TdZdd にデシリアライズ機能がないため自前実装が必要。
現状の分割方式で十分メモリが削減されているので、優先度は低い。

---

## 重要なファイル

| ファイル | 役割 |
|---|---|
| `cpp/spanning_tree_zdd/src/main.cpp` | メインプログラム。Phase 4/5/6 のパイプライン |
| `cpp/spanning_tree_zdd/src/SymmetryFilter.hpp` | g-不変性フィルタ (DdSpec) |
| `cpp/spanning_tree_zdd/src/UnfoldingFilter.hpp` | 非重複フィルタ (DdSpec) |
| `cpp/spanning_tree_zdd/src/SpanningTree.hpp` | 全域木 ZDD 構築 (DdSpec) |
| `cpp/spanning_tree_zdd/src/BigUInt.hpp` | 任意幅ビットマスク型 |
| `lib/tdzdd/include/tdzdd/DdSpecOp.hpp` | zddIntersection 等のスペック合成 |
| `lib/tdzdd/include/tdzdd/DdStructure.hpp` | ZDD の主要データ構造 |

## テストコマンド

```bash
# ビルド
cd build && make -j8

# n20 テスト
./build/spanning_tree_zdd \
  data/polyhedra/johnson/n20/polyhedron.grh \
  data/polyhedra/johnson/n20/unfoldings_edge_sets.jsonl \
  --automorphisms data/polyhedra/johnson/n20/automorphisms.json

# s12L テスト（メモリ計測付き）
/usr/bin/time -l ./build/spanning_tree_zdd \
  data/polyhedra/archimedean/s12L/polyhedron.grh \
  data/polyhedra/archimedean/s12L/unfoldings_edge_sets.jsonl \
  --automorphisms data/polyhedra/archimedean/s12L/automorphisms.json
```

### 期待される正解値

- n20: `nonisomorphic_count = 2715815541`
- s12L: `nonisomorphic_count = 3581988230895`
