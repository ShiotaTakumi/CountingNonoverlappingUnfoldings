# 2026-02-20 作業ログ

## 概要

### セッション 1: Phase 6 のみの ZDD 分割

Phase 6（Burnside の補題による非同型数え上げ）のメモリ最適化を行った。
ZDD を分割して SymmetryFilter を適用する方式により、s12L のピークメモリを 6.5GB → 2.8GB に削減（57% 削減）。時間も 62.5s → 53.2s に高速化（15% 高速化）。

### セッション 2: Phase 4→5→6 全パイプラインの分割（`--split-depth N`）

Phase 6 のみの分割を発展させ、Phase 4→5→6 の全パイプラインをパーティション単位で実行する `--split-depth N` オプションを導入。各パーティションは Phase 4（ZDD 構築）→ Phase 5（MOPE フィルタ）→ Phase 6（Burnside）を独立に実行し、完了後にメモリを完全解放する。これにより、ピークメモリが 1 パーティション分に抑えられる。
s12L での計測: split_depth=8 で 712MB（元の 5.4GB から 87% 削減）。時間は増加するが、メモリ制約下での大規模インスタンス計算を可能にすることが目的。

---

## 背景

### プロジェクト構成

CountingNonoverlappingUnfoldings: 多面体の非重複展開図を数え上げるプロジェクト。

パイプライン:
- Phase 4: 全域木 ZDD 構築（SpanningTree DdSpec）
- Phase 5: 非重複フィルタリング（UnfoldingFilter で MOPE ごとに zddSubset + zddReduce）
- Phase 6: Burnside の補題で非同型数え上げ（SymmetryFilter で各自己同型 g に対して |T_g| を計算）

### Phase 6 のボトルネック

各非恒等自己同型 g に対して:
1. Phase 5 結果 ZDD を deep copy（`privateEntity()` で refCount=1 に）
2. `zddSubset(SymmetryFilter)` → unreduced 中間 ZDD が巨大（s12L: 574M ノード = 8.7GB）
3. `zddReduce()` → reduce 中に旧テーブル + 新テーブルが同時存在
4. `zddCardinality()` → カウント

ピークメモリは step 2 の unreduced 中間 ZDD が支配的。

---

## 今回の変更内容

### 変更ファイル

- `cpp/spanning_tree_zdd/src/main.cpp` のみ

### 変更の要点

**ZDD 分割 + shallow copy 方式** を導入:

1. **EdgeRestrictor DdSpec** を新規追加（main.cpp 内に定義）
   - 上位 `depth` 辺（辺0, 辺1, ... 辺depth-1）の値を特定のビットパターンに制約するフィルタ
   - `tdzdd::DdSpec<EdgeRestrictor, int, 2>` を継承

2. **`#include <tdzdd/DdSpecOp.hpp>`** を追加
   - `tdzdd::zddIntersection()` を使用するため

3. **`run_burnside_with_bitmask` の非恒等自己同型処理を変更**

   旧:
   ```cpp
   tdzdd::DdStructure<2> dd_copy(dd);
   dd_copy.getDiagram().privateEntity();  // deep copy
   SymmetryFilter<BitMask> filter(num_edges, perm);
   dd_copy.zddSubset(filter);
   dd_copy.zddReduce();
   count = dd_copy.zddCardinality();
   ```

   新:
   ```cpp
   const int split_depth = 3;  // K=8 パーティション
   const int num_partitions = 1 << split_depth;
   string partition_sum = "0";

   for (int p = 0; p < num_partitions; ++p) {
       tdzdd::DdStructure<2> dd_part(dd);  // shallow copy (deep copy 不要)

       EdgeRestrictor restrictor(num_edges, split_depth, p);
       SymmetryFilter<BitMask> sym_filter(num_edges, perm);
       auto combined = tdzdd::zddIntersection(restrictor, sym_filter);
       dd_part.zddSubset(combined);
       dd_part.zddReduce();

       partition_sum = bigint_add(partition_sum, dd_part.zddCardinality());
   }
   count = partition_sum;
   ```

### なぜ動くか

- 「辺0=0 の全域木」と「辺0=1 の全域木」は排他的 (disjoint)
- 上位 d 辺で 2^d パーティションに分割 → 各パーティションの中間 ZDD ≈ 元の 1/2^d
- パーティションが排他的なので zddUnion 不要、**カーディナリティを足すだけ**
- `zddIntersection(EdgeRestrictor, SymmetryFilter)` で合成フィルタを作成し、1 回の zddSubset で分割制約 + 対称性フィルタを同時適用
- EdgeRestrictor が上位レベルで即座に枝刈り → SymmetryFilter の処理対象が 1/K に

### なぜ shallow copy で動くか

- `zddSubset_()` 内の `diagram.derefLevel(i)` は refCount==1 の場合のみレベルを解放
- shallow copy (refCount=2) では derefLevel は no-op → 入力 ZDD は解放されないが subset 結果は正しい
- deep copy コスト（`privateEntity()` の全テーブルコピー）が完全に不要に

---

## 計測結果

### n20 (Johnson 立体, 45辺, 自己同型群位数10)

| | Phase 6 時間 | ピークメモリ |
|---|---|---|
| 元の実装 | 217ms | 162MB |
| 分割方式 (K=8) | 302ms | **79MB** |
| 変化 | +39% | **-51%** |

### s12L (Archimedean 立体, 60辺, 自己同型群位数24)

| | Phase 6 時間 | ピークメモリ |
|---|---|---|
| 元の実装 | 62.5s | **6.5GB** |
| 分割方式 (K=8) | 53.2s | **2.8GB** |
| 変化 | **-15%** | **-57%** |

### 正解値

- n20: nonisomorphic_count = `2715815541` ✓
- s12L: nonisomorphic_count = `3581988230895` ✓

---

## 試して失敗したアプローチ（この会話内）

### 1. InvariantCounter.hpp（自作 subsetter）

前回の会話で作成した ZddSubsetter を模倣した自作実装。
s12L: 53s / 5.5GB と高速化・メモリ削減できたが、TdZdd ライブラリの内部構造を再現しているためバグリスクが高い。ユーザ判断で revert。

### 2. zddReduce 追加（InvariantCounter + DdReducer）

InvariantCounter の出力に DdReducer を適用。n20 では効果あり（94MB）だが s12L では逆効果（8.2GB）。DdReducer 内部で privateEntity() がテーブルをコピーするため、巨大な unreduced ZDD に対しては逆にメモリが増加。

### 3. zddIntersection(SpanningTree, SymmetryFilter) で直接構築

g-不変全域木 ZDD を SpanningTree と SymmetryFilter の intersection で直接構築。
理論上は良いが、combined state（frontier 状態 + BitMask）の爆発 + 72 MOPEs を各自己同型ごとに再適用するため、s12L で非常に遅い。n20 でも Phase 6 が 678ms に悪化。

---

## 現在の状態（セッション 1 終了時）

- `main.cpp` は変更済み・**未コミット**
- `InvariantCounter.hpp` は削除済み
- ビルド済み・テスト通過
- `git status` で差分あり

---

---

# セッション 2: 全パイプライン分割（`--split-depth N`）

## 背景

セッション 1 の Phase 6 のみの分割は s12L で効果的（6.5GB → 2.8GB）だったが、Phase 4+5 で構築された ZDD 自体が巨大な場合、Phase 6 の分割だけではメモリが足りない。s06（約 120 辺）のような大規模インスタンスを計算するには、Phase 4 から Phase 6 まで全体をパーティション単位で実行し、各パーティション完了後にメモリを完全解放する必要がある。

## 設計方針

- `--split-depth N` コマンドライン引数（デフォルト 0 = 分割なし）
- 上位 N 辺のビットパターンで 2^N パーティションに分割
- 各パーティション内で Phase 4→5→6 を独立に実行
  - Phase 4: `zddIntersection(SpanningTree, EdgeRestrictor)` で分割済み全域木 ZDD を構築
  - Phase 5: MOPE フィルタリング（通常通り）
  - Phase 6: Burnside の補題（各自己同型ごとの |T_g| をパーティション間で累積加算）
- パーティションは排他的 → カーディナリティを足すだけで OK
- dd がスコープ外に出ると自動的にメモリ解放 → ピークメモリ ≈ 1 パーティション分

### split_depth の自動決定について

ZDD サイズはグラフ構造に強く依存するため、辺数やメモリサイズから事前予測は困難。手動で `--split-depth N` を指定する方式とした。

---

## 変更内容

### 変更ファイル

- `cpp/spanning_tree_zdd/src/main.cpp` — 主要な変更
- `python/counting/cli.py` — Python CLI に `--split-depth` 引数追加
- `README.md` — 使い方ドキュメント更新

### main.cpp の変更要点

1. **`--split-depth N` 引数パース追加**
   - 0–30 の範囲、`split_depth >= num_edges` でエラー
   - JSON 出力に `split_depth` フィールド追加（> 0 の場合）

2. **`run_partitioned_pipeline<BitMask>` テンプレート関数を新規追加**

   ```cpp
   template<typename BitMask>
   void run_partitioned_pipeline(
       const Graph& G, int num_edges, int split_depth,
       bool apply_filter, const vector<set<int>>& MOPEs,
       bool apply_burnside, const vector<vector<int>>& edge_permutations,
       const vector<bool>& zero_flags,
       string& spanning_tree_count, string& non_overlapping_count,
       vector<string>& invariant_counts, string& burnside_sum,
       double& build_time_ms, double& subset_time_ms, double& burnside_time_ms
   );
   ```

   - 2^N パーティションをループ
   - 各パーティション内で Phase 4→5→6 を独立実行
   - `spanning_tree_count`, `non_overlapping_count`, `invariant_counts[i]` をパーティション間で `bigint_add` で累積
   - dd のスコープが for ループ内 → パーティション完了後に自動解放

3. **`run_burnside_with_bitmask` を簡略化**
   - セッション 1 で追加した Phase 6-only の分割ロジックを削除
   - シンプルな shallow copy + SymmetryFilter + zddSubset + zddReduce に戻す
   - 分割は `run_partitioned_pipeline` が全パイプラインレベルで担当

4. **main() の分岐**
   - `split_depth > 0` → `run_partitioned_pipeline` を呼び出し
   - `split_depth == 0` → 従来の標準パイプライン（変更なし）
   - MOPEs とオートモーフィズムの読み込みをパイプライン実行前に移動

5. **`count_time_ms` を JSON 出力から削除**
   - リファクタリングにより不要になった変数を除去

### python/counting/cli.py の変更

- `--split-depth` 引数を argparse に追加
- `run_pipeline()` に `split_depth` パラメータ追加
- `split_depth > 0` の場合、C++ バイナリに `--split-depth N` を渡す

### README.md の変更

- `--split-depth 4` の使用例を追加
- 引数テーブルに `--split-depth N` 行を追加

---

## 全 Phase 組み合わせ対応

`--split-depth` は以下の全組み合わせで動作確認済み:

| Phase 組み合わせ | 説明 |
|---|---|
| Phase 4 のみ | `--split-depth N` のみ指定（MOPEs/automorphisms なし） |
| Phase 4+5 | `--split-depth N` + MOPEs 指定 |
| Phase 4+6 | `--split-depth N` + automorphisms 指定（MOPEs なし） |
| Phase 4+5+6 | `--split-depth N` + MOPEs + automorphisms 指定 |

---

## 計測結果

### n20 (Johnson 立体, 45辺, 自己同型群位数10) — 正確性検証

| split_depth | Phase 組み合わせ | 結果 | 正解 |
|---|---|---|---|
| 0 | Phase 4+5+6 | 2715815541 | ✓ |
| 2 | Phase 4+5+6 | 2715815541 | ✓ |
| 3 | Phase 4 only | 29821320745 | ✓ |
| 3 | Phase 4+5 | 27158087415 | ✓ |
| 3 | Phase 4+6 | 2982139245 | ✓ |

### s12L (Archimedean 立体, 60辺, 自己同型群位数24) — メモリベンチマーク

| split_depth | パーティション数 | ピークメモリ | 全体時間 |
|---|---|---|---|
| 0 | 1 | **5.4 GB** | 94s |
| 2 | 4 | **3.3 GB** | 90s |
| 4 | 16 | **1.6 GB** | 102s |
| 8 | 256 | **712 MB** | 206s |

全て nonisomorphic_count = `3581988230895` ✓

### メモリ vs 時間のトレードオフ

- split_depth を増やすとメモリは指数的に減少するが、時間は増加
- split_depth=2 は時間ペナルティほぼなしでメモリ 39% 削減
- split_depth=8 はメモリ 87% 削減だが時間 2.2 倍
- 時間よりメモリが重要なユースケース（大規模インスタンス）向け

---

## 安全性

- TdZdd の **公開 API のみ** を使用
  - `DdStructure` コンストラクタ、`zddSubset`、`zddReduce`、`zddCardinality`
  - `tdzdd::zddIntersection` (DdSpecOp.hpp)
  - `DdSpec` の継承（EdgeRestrictor）
- 内部 API（privateEntity、diagram 直接操作等）は不使用
- ライブラリのバージョンアップ時にも安全

---

## 現在の状態

- `main.cpp`, `cli.py`, `README.md` 変更済み
- `InvariantCounter.hpp` は削除済み
- ビルド済み・テスト通過（n20 全組み合わせ、s12L 4 パターン）
- **未コミット**

---

## 次に必要なこと

### 1. コミット

現在の変更をコミットする。

### 2. より大きなインスタンスでのテスト

s06（約 120 辺）等の大規模インスタンスで `--split-depth` を大きく設定して実行可能か検証。

### 3. ディスク I/O 方式（将来の検討）

Phase 5 ZDD 自体をディスクに書き出し、各パーティション処理時に読み込む方式。
TdZdd にデシリアライズ機能がないため自前実装が必要。
現状の分割方式で十分メモリが削減されているので、優先度は低い。

---

## 重要なファイル

| ファイル | 役割 |
|---|---|
| `cpp/spanning_tree_zdd/src/main.cpp` | メインプログラム。Phase 4/5/6 のパイプライン |
| `cpp/spanning_tree_zdd/src/SymmetryFilter.hpp` | g-不変性フィルタ (DdSpec) |
| `cpp/spanning_tree_zdd/src/UnfoldingFilter.hpp` | 非重複フィルタ (DdSpec) |
| `cpp/spanning_tree_zdd/src/SpanningTree.hpp` | 全域木 ZDD 構築 (DdSpec) |
| `cpp/spanning_tree_zdd/src/BigUInt.hpp` | 任意幅ビットマスク型 |
| `lib/tdzdd/include/tdzdd/DdSpecOp.hpp` | zddIntersection 等のスペック合成 |
| `lib/tdzdd/include/tdzdd/DdStructure.hpp` | ZDD の主要データ構造 |
| `python/counting/cli.py` | Python CLI ラッパー |

## テストコマンド

```bash
# ビルド
cd build && make -j8

# n20 テスト（分割なし）
./build/spanning_tree_zdd \
  data/polyhedra/johnson/n20/polyhedron.grh \
  data/polyhedra/johnson/n20/unfoldings_edge_sets.jsonl \
  --automorphisms data/polyhedra/johnson/n20/automorphisms.json

# n20 テスト（split-depth=3）
./build/spanning_tree_zdd \
  data/polyhedra/johnson/n20/polyhedron.grh \
  data/polyhedra/johnson/n20/unfoldings_edge_sets.jsonl \
  --automorphisms data/polyhedra/johnson/n20/automorphisms.json \
  --split-depth 3

# s12L テスト（メモリ計測付き、split-depth=4）
/usr/bin/time -l ./build/spanning_tree_zdd \
  data/polyhedra/archimedean/s12L/polyhedron.grh \
  data/polyhedra/archimedean/s12L/unfoldings_edge_sets.jsonl \
  --automorphisms data/polyhedra/archimedean/s12L/automorphisms.json \
  --split-depth 4
```

### 期待される正解値

- n20: `nonisomorphic_count = 2715815541`
- s12L: `nonisomorphic_count = 3581988230895`
